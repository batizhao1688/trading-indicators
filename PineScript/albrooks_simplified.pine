//@version=5
indicator("Al Brooks 8-Step Simplified", overlay=true, max_bars_back=500)

// ============================================
// Al Brooks八步演化系统 - 简化实用版
// GitHub: https://github.com/batizhao1688/trading-indicators
// ============================================

// =============== 核心参数配置 ===============
// 急速行情参数
rapidMinBars = input.int(3, "急速最少K线数", minval=2, maxval=5)
rapidBodyMult = input.float(1.8, "实体倍数", minval=1.2, maxval=3.0)
rapidMaxOverlap = input.float(30, "最大重叠%", minval=10, maxval=50) / 100

// 通道参数
channelLookback = input.int(20, "通道检测窗口", minval=10, maxval=50)
channelMinTouches = input.int(2, "最少触及次数", minval=2, maxval=5)
channelSlopeRatio = input.float(0.6, "通道斜率比", minval=0.3, maxval=1.0)

// 可视化参数
showChannel = input.bool(true, "显示通道")
showRapid = input.bool(true, "显示急速行情")
showKeyPoints = input.bool(true, "显示关键点")
showInfo = input.bool(true, "显示信息面板")

// =============== 状态定义 ===============
// 5个核心状态
var string currentState = "INITIAL"
var int stateStartBar = 0
var string rapidType = ""

// 状态枚举
INITIAL = "等待急速"
SPIKE_DETECTED = "急速识别"
CHANNEL_FORMING = "通道形成"
CHANNEL_ACTIVE = "通道活跃"
TEST_EXTREME = "测试极值"

// =============== 工具函数 ===============
bodySize(idx) => math.abs(close[idx] - open[idx])

avgBody(idx, length) =>
    sum = 0.0
    for i = 0 to length - 1
        if idx + i >= 0
            sum += bodySize(idx + i)
    sum / length

// =============== 急速检测 ===============
var bool rapidDetected = false
var int rapidStartIdx = 0
var int rapidEndIdx = 0
var bool rapidBullish = false
var float rapidStrength = 0.0

// 简化检测逻辑
checkRapid() =>
    detected = false
    startIdx = 0
    endIdx = 0
    bullish = false
    strength = 0.0
    
    // 检查最近20根K线
    for i = 0 to 19
        idx = bar_index - i
        if idx >= 0
            avgBody20 = avgBody(idx, 20)
            currentBody = bodySize(idx)
            
            // 检查实体倍数
            if currentBody > avgBody20 * rapidBodyMult
                // 检查连续性
                consecutive = 1
                for j = 1 to rapidMinBars - 1
                    if idx + j < bar_count
                        nextBody = bodySize(idx + j)
                        nextAvg = avgBody(idx + j, 20)
                        if nextBody > nextAvg * rapidBodyMult
                            consecutive += 1
                
                if consecutive >= rapidMinBars
                    detected := true
                    startIdx := idx
                    endIdx := idx + consecutive - 1
                    bullish := close[idx] > open[idx]
                    
                    // 简单强度计算
                    bodyRatio = currentBody / avgBody20
                    strength := math.min(10, (bodyRatio - 1) * 5)
                    break
    
    [detected, startIdx, endIdx, bullish, strength]

// =============== 通道计算 ===============
calculateChannel(startIdx, endIdx) =>
    lookback = endIdx - startIdx + 1
    
    // 线性回归计算
    sumX = 0.0, sumY = 0.0, sumXY = 0.0, sumXX = 0.0
    for i = 0 to lookback - 1
        idx = startIdx + i
        if idx >= 0
            x = i
            y = close[idx]
            sumX += x
            sumY += y
            sumXY += x * y
            sumXX += x * x
    
    // 回归线
    slope = (lookback * sumXY - sumX * sumY) / (lookback * sumXX - sumX * sumX)
    intercept = (sumY - slope * sumX) / lookback
    
    // 通道边界
    upperValues = array.new<float>()
    lowerValues = array.new<float>()
    
    for i = 0 to lookback - 1
        idx = startIdx + i
        regY = intercept + slope * i
        
        // 简单通道：回归线 ± 平均范围
        avgRange = ta.sma(high[idx] - low[idx], 10)
        upperVal = regY + avgRange * 0.5
        lowerVal = regY - avgRange * 0.5
        
        array.push(upperValues, upperVal)
        array.push(lowerValues, lowerVal)
    
    [array.get(upperValues, array.size(upperValues) - 1), 
     array.get(lowerValues, array.size(lowerValues) - 1), 
     slope]

// =============== 状态机更新 ===============
updateStateMachine() =>
    // 检测急速
    [detected, rStart, rEnd, rBullish, rStrength] = checkRapid()
    
    if detected and currentState == "INITIAL"
        currentState := "SPIKE_DETECTED"
        stateStartBar := bar_index
        rapidDetected := true
        rapidStartIdx := rStart
        rapidEndIdx := rEnd
        rapidBullish := rBullish
        rapidStrength := rStrength
        
        // 确定急速类型
        if rStrength >= 7
            rapidType := "爆发型"
        else if rStrength >= 5
            rapidType := "加速型"
        else
            rapidType := "标准型"
    
    else if currentState == "SPIKE_DETECTED" and bar_index - stateStartBar >= 5
        currentState := "CHANNEL_FORMING"
    
    else if currentState == "CHANNEL_FORMING" and bar_index - stateStartBar >= 10
        currentState := "CHANNEL_ACTIVE"
    
    else if currentState == "CHANNEL_ACTIVE"
        // 检查是否测试通道边界
        [upper, lower, slope] = calculateChannel(rapidStartIdx, bar_index)
        
        if rapidBullish
            if high >= upper * 0.98  // 接近上轨
                currentState := "TEST_EXTREME"
        else
            if low <= lower * 1.02  // 接近下轨
                currentState := "TEST_EXTREME"
    
    // 状态超时处理
    if bar_index - stateStartBar > 100
        currentState := "INITIAL"
        rapidDetected := false

// =============== 主逻辑 ===============
// 更新状态机
updateStateMachine()

// 计算当前通道
var float currentUpper = na
var float currentLower = na
var float currentSlope = 0.0

if rapidDetected
    [upper, lower, slope] = calculateChannel(rapidStartIdx, bar_index)
    currentUpper := upper
    currentLower := lower
    currentSlope := slope

// =============== 可视化 ===============
// 1. 绘制通道
if showChannel and rapidDetected and not na(currentUpper)
    // 上轨
    lineUp = line.new(bar_index - (bar_index - rapidStartIdx), currentUpper, 
                      bar_index, currentUpper, 
                      color=color.new(color.blue, 70), width=1)
    
    // 下轨
    lineLow = line.new(bar_index - (bar_index - rapidStartIdx), currentLower, 
                       bar_index, currentLower, 
                       color=color.new(color.blue, 70), width=1)
    
    // 通道填充
    boxId = box.new(bar_index - (bar_index - rapidStartIdx), currentUpper,
                    bar_index, currentLower,
                    bgcolor=color.new(color.blue, κ品)