//@version=5
indicator("Channel Three Push System", shorttitle="CTPS", overlay=true, max_lines_count=500, max_labels_count=100)

// ========== 配置参数 ==========
rapidLen = input.int(10, "急速行情检测窗口", minval=5, maxval=50)
rapidMultiplier = input.float(1.5, "实体倍数阈值", minval=1.2, maxval=3.0)
minRapidBars = input.int(2, "最少急速K线数", minval=2, maxval=5)

channelLookback = input.int(20, "通道检测窗口", minval=10, maxval=50)
minTouchPoints = input.int(3, "最少接触点数", minval=2, maxval=10)
channelSlopeThreshold = input.float(0.6, "通道斜率阈值", minval=0.3, maxval=1.0)

push1MinHeight = input.float(0.6, "第一段最小高度%", minval=0.4, maxval=0.8, step=0.05)
push2MaxHeight = input.float(0.8, "第二段最大高度%", minval=0.5, maxval=1.0, step=0.05)
overshootThreshold = input.float(0.2, "过冲阈值%", minval=0.1, maxval=0.5, step=0.05)

failureBars = input.int(5, "衰竭验证K线数", minval=3, maxval=10)
minSwingCount = input.int(2, "最少摆动次数", minval=1, maxval=5)
reversalConfirmation = input.int(1, "反转确认K线数", minval=1, maxval=3)

showLabels = input.bool(true, "显示标签")
showLines = input.bool(true, "显示线条")
colorBullish = input.color(color.green, "多头颜色")
colorBearish = input.color(color.red, "空头颜色")
colorNeutral = input.color(color.blue, "中性颜色")
showAlerts = input.bool(true, "显示警报")
showTable = input.bool(true, "显示信息表格")

// ========== 核心计算函数 ==========
bodySize = math.abs(close - open)
avgBodySize = ta.sma(bodySize, rapidLen)

// 急速行情检测
isRapidBullish = false
rapidBullishCount = 0
for i = 0 to rapidLen - 1
    barBody = bodySize[i]
    avgBody = avgBodySize[i+1]
    if close[i] > open[i] and barBody > avgBody * rapidMultiplier
        rapidBullishCount := rapidBullishCount + 1
    else
        rapidBullishCount := 0
    if rapidBullishCount >= minRapidBars
        isRapidBullish := true
        break

isRapidBearish = false
rapidBearishCount = 0
for i = 0 to rapidLen - 1
    barBody = bodySize[i]
    avgBody = avgBodySize[i+1]
    if close[i] < open[i] and barBody > avgBody * rapidMultiplier
        rapidBearishCount := rapidBearishCount + 1
    else
        rapidBearishCount := 0
    if rapidBearishCount >= minRapidBars
        isRapidBearish := true
        break

// 急速行情结束点
var int rapidEndBar = na
if (isRapidBullish or isRapidBearish) and na(rapidEndBar)
    rapidEndBar := bar_index
else if not (isRapidBullish or isRapidBearish) and not na(rapidEndBar)
    rapidEndBar := na

// 通道计算
var line upperLine = na
var line lowerLine = na
var float channelSlopeVal = na
var float channelStartVal = na
var float channelHeightVal = na

if not na(rapidEndBar) and bar_index >= rapidEndBar + 5
    lookback = math.min(channelLookback, bar_index - rapidEndBar)
    sumX = 0.0
    sumY = 0.0
    sumXY = 0.0
    sumXX = 0.0
    for i = 0 to lookback - 1
        x = i
        y = close[i]
        sumX := sumX + x
        sumY := sumY + y
        sumXY := sumXY + x * y
        sumXX := sumXX + x * x
    
    n = lookback
    slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)
    intercept = (sumY - slope * sumX) / n
    
    // 找到通道起点
    startPrice = low[rapidEndBar - bar_index]
    for i = rapidEndBar + 1 to rapidEndBar + lookback
        idx = i - bar_index
        if idx >= 0 and low[idx] < startPrice
            startPrice := low[idx]
    
    currentIdx = bar_index - rapidEndBar
    upperPrice = intercept + slope * currentIdx
    channelHeight = upperPrice - startPrice
    
    if showLines
        line.delete(upperLine[1])
        line.delete(lowerLine[1])
        upperLine := line.new(bar_index - lookback, upperPrice - channelHeight, bar_index, upperPrice, color=colorNeutral, width=1)
        lowerLine := line.new(bar_index - lookback, startPrice, bar_index, startPrice + channelHeight, color=colorNeutral, width=1)
    
    channelSlopeVal := math.abs(slope)
    channelStartVal := startPrice
    channelHeightVal := channelHeight

// 三段推动识别
var int push1End = na
var float push1Height = na
var int push2End = na
var float push2Height = na
var int push3End = na
var float push3Height = na

if not na(upperLine) and not na(lowerLine)
    upperPrice = line.get_y2(upperLine)
    lowerPrice = line.get_y1(lowerLine)
    heightVal = channelHeightVal
    
    currentPos = (close - lowerPrice) / heightVal
    
    // 第一段推动
    if na(push1End) and currentPos <= 0.3 and currentPos >= 0.7
        push1End := bar_index
        push1Height := currentPos * 100
    
    // 第二段推动
    if not na(push1End) and na(push2End) and currentPos >= 0.5
        if currentPos * 100 < push1Height * push2MaxHeight
            push2End := bar_index
            push2Height := currentPos * 100
    
    // 第三段推动
    if not na(push2End) and na(push3End)
        overshoot = (high - upperPrice) / heightVal
        if overshoot > 0 and overshoot <= overshootThreshold
            push3End := bar_index
            push3Height := overshoot * 100

// 衰竭信号检测
var bool failureDetected = false
var int failureBar = na

if not na(push3End) and bar_index <= push3End + failureBars
    for i = 1 to failureBars
        checkBar = push3End + i
        if checkBar <= bar_index
            checkIdx = checkBar - bar_index
            checkPrice = close[checkIdx]
            if not na(upperLine) and not na(lowerLine)
                checkPos = (checkPrice - line.get_y1(lowerLine)) / channelHeightVal
                if checkPos < 1.0
                    failureDetected := true
                    failureBar := checkBar
                    break
    
    if not failureDetected
        for i = 0 to math.min(2, failureBars - 1)
            idx = push3End + i - bar_index
            if idx >= 0
                engulfBearish = close[idx] < open[idx] and high[idx] >= high[idx-1] and low[idx] <= low[idx-1]
                body = math.abs(close[idx] - open[idx])
                range = high[idx] - low[idx]
                upperWick = high[idx] - math.max(close[idx], open[idx])
                lowerWick = math.min(close[idx], open[idx]) - low[idx]
                pinBar = body < range * 0.3 and upperWick > lowerWick * 2
                if engulfBearish or pinBar
                    failureDetected := true
                    failureBar := push3End + i
                    break

// ========== 可视化 ==========
// 背景色标记
bgcolor(isRapidBullish ? color.new(colorBullish, 85) : isRapidBearish ? color.new(colorBearish, 85) : na)

// 标签显示
if showLabels
    if not na(push1End)
        label.new(push1End, high[push1End - bar_index] + channelHeightVal * 0.05, "推1\n" + str.tostring(push1Height, "#.#") + "%", color=colorBullish, style=label.style_label_up, size=size.small)
    if not na(push2End)
        label.new(push2End, high[push2End - bar_index] + channelHeightVal * 0.05, "推2\n" + str.tostring(push2Height, "#.#") + "%", color=color.new(colorBullish, 50), style=label.style_label_up, size=size.small)
    if not na(push3End)
        labelColor = failureDetected ? colorBearish : colorNeutral
        label.new(push3End, high[push3End - bar_index] + channelHeightVal * 0.08, "推3\n" + str.tostring(push3Height, "#.#") + "%", color=labelColor, style=label.style_label_up, size=size.small)
    if failureDetected and not na(failureBar)
        label.new(failureBar, low[failureBar - bar_index] - channelHeightVal * 0.05, "衰竭!", color=colorBearish, style=label.style_label_down, size=size.normal)

// 水平线（在全局作用域）
hlinePrice1 = not na(channelStartVal) ? channelStartVal : na
hlinePrice2 = not na(push1End) ? high[push1End - bar_index] : na

if showLines and not na(hlinePrice1)
    hline(hlinePrice1, "通道起点", color=color.orange, linestyle=hline.style_dashed)
if showLines and not na(hlinePrice2)
    hline(hlinePrice2, "通道极值", color=color.purple, linestyle=hline.style_dotted)

// 信息表格
if barstate.islast and showTable
    infoTable = table.new(position.top_right, 3, cell_text_color=color.white)
    
    table.cell(infoTable, 0, 0, "通道三段推动系统", bgcolor=color.blue)
    table.cell(infoTable, 1, 0, "状态")
    table.cell(infoTable, 2, 0, "数值")
    
    // 急速行情状态
    rapidStatus = isRapidBullish ? "多头" : isRapidBearish ? "空头" : "无"
    rapidColor = isRapidBullish ? color.green : isRapidBearish ? color.red : color.gray
    table.cell(infoTable, 0, 1, "急速行情", text_color=color.gray)
    table.cell(infoTable, 1, 1, rapidStatus, bgcolor=rapidColor)
    table.cell(infoTable, 2, 1, na)
    
    // 通道斜率
    if not na(channelSlopeVal)
        slopeColor = channelSlopeVal < channelSlopeThreshold ? color.green : color.red
        table.cell(infoTable, 0, 2, "通道斜率", text_color=color.gray)
        table.cell(infoTable, 1, 2, str.tostring(channelSlopeVal, "#.####"))
        table.cell(infoTable, 2, 2, channelSlopeVal < channelSlopeThreshold ? "正常" : "过陡", bgcolor=slopeColor)
    
    // 三段推动进度
    pushCount = (not na(push1End) ? 1 : 0) + (not na(push2End) ? 1 : 0) + (not na(push3End) ? 1 : 0)
    pushStatus = pushCount == 3 ? "完成" : pushCount > 0 ? str.tostring(pushCount) + "/3" : "等待"
    pushColor = pushCount == 3 ? color.blue : pushCount > 0 ? color.orange : color.gray
    table.cell(infoTable, 0, 3, "三段推动", text_color=color.gray)
    table.cell(infoTable, 1, 3, pushStatus)
    table.cell(infoTable, 2, 3, str.tostring(pushCount) + "段", bgcolor=pushColor)
    
    // 衰竭信号
    failureStatus = failureDetected ? "检测到" : "无"
    failureColor = failureDetected ? color.red : color.gray
    table.cell(infoTable, 0, 4, "衰竭信号", text_color=color.gray)
    table.cell(infoTable, 1, 4, failureStatus)
    table.cell(infoTable, 2, 4, failureDetected ? "警惕" : "安全", bgcolor=failureColor)
    
    // 通道高度
    if not na(channelHeightVal)
        table.cell(infoTable, 0, 5, "通道高度", text_color=color.gray)
        table.cell(infoTable, 1, 5, str.tostring(channelHeightVal, "#.##"))
        table.cell(infoTable, 2, 5, str.tostring(channelHeightVal / close * 100, "#.##") + "%")
    
    // 当前位置
    if not na(upperLine) and not na(lowerLine)
        upperPrice = line.get_y2(upperLine)
        lowerPrice = line.get_y1(lowerLine)
        currentPos = (close - lowerPrice) / channelHeightVal * 100
        posColor = currentPos > 70 ? color.red : currentPos < 30 ? color.green : color.yellow
        table.cell(infoTable, 0, 6, "当前位置", text_color=color.gray)
        table.cell(infoTable, 1, 6, str.tostring(currentPos, "#.#") + "%", bgcolor=posColor)
        posDesc = currentPos > 70 ? "上轨附近" : currentPos < 30 ? "下轨附近" : "通道中部"
        table.cell(infoTable, 2, 6, posDesc)

// 警报（在全局作用域）
alertcondition(isRapidBullish or isRapidBearish, "急速行情", "检测到急速行情")
if not na(push1End) and not na(push2End) and not na(push3End)
    alertcondition(true, "三段推动完成", "三段推动形态完成")
alertcondition(failureDetected, "衰竭信号", "检测到通道衰竭信号")

// 图形标记
plotshape(isRapidBullish, "多头急速", shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(isRapidBearish, "空头急速", shape.triangledown, location.abovebar, color.red, size=size.small)
if failureDetected
    plotshape(failureBar == bar_index, "衰竭点", shape.xcross, location.abovebar, color.red, size=size.normal)

// 系统说明
// 本指标实现"通道三段式推动"交易系统
// 1. 趋势结构识别（急速行情+通道）
// 2. 通道平衡验证（规律摆动）
// 3. 过冲衰竭识别（虚假突破）
// 4. 趋势线突破确认
// 5. 双重顶形态验证
// 6. 通道起点支撑测试
// 7. 交易区间形成与突破